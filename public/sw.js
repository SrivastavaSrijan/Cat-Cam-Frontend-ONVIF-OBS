/* eslint-disable no-restricted-globals */
/* eslint-disable no-undef */

// This is the "Offline page" service worker
// Using importScripts for better compatibility

importScripts('https://storage.googleapis.com/workbox-cdn/releases/6.6.0/workbox-sw.js');

const { clientsClaim, skipWaiting } = workbox.core;
const { ExpirationPlugin } = workbox.expiration;
const { precacheAndRoute, createHandlerBoundToURL } = workbox.precaching;
const { registerRoute } = workbox.routing;
const { NetworkOnly, StaleWhileRevalidate } = workbox.strategies;

clientsClaim();
skipWaiting();

// Precache all of the assets generated by your build process.
precacheAndRoute(self.__WB_MANIFEST);

// Set up App Shell-style routing
const fileExtensionRegexp = /\/[^/?]+\.[^/]+$/;
registerRoute(
  ({ request, url }) => {
    if (request.mode !== 'navigate') {
      return false;
    }
    if (url.pathname.startsWith('/_')) {
      return false;
    }
    if (url.pathname.match(fileExtensionRegexp)) {
      return false;
    }
    return true;
  },
  createHandlerBoundToURL('/index.html')
);

// NEVER cache MJPEG streams or any video streams - always fetch fresh
registerRoute(
  ({ url }) => url.pathname.includes('/mjpeg') || 
               url.pathname.includes('/stream') || 
               url.pathname.includes('mjpeg') ||
               url.pathname.includes('video') ||
               url.searchParams.has('stream'),
  new NetworkOnly({
    // Force fresh fetch, no caching whatsoever
  })
);

// NEVER cache API calls - always fetch fresh for real-time data
registerRoute(
  ({ url }) => url.pathname.startsWith('/api') ||
               url.pathname.includes('/status') ||
               url.pathname.includes('/control') ||
               url.pathname.includes('/camera'),
  new NetworkOnly({
    // Force fresh fetch for all API calls
  })
);

// Only cache static assets like images, CSS, JS (but not streams)
registerRoute(
  ({ url }) => url.origin === self.location.origin && 
               (url.pathname.endsWith('.png') || 
                url.pathname.endsWith('.jpg') || 
                url.pathname.endsWith('.jpeg') ||
                url.pathname.endsWith('.ico') ||
                url.pathname.endsWith('.svg')) &&
               !url.pathname.includes('/mjpeg') &&
               !url.pathname.includes('/stream'),
  new StaleWhileRevalidate({
    cacheName: 'static-images',
    plugins: [
      new ExpirationPlugin({ maxEntries: 30 }),
    ],
  })
);

// Handle skip waiting
self.addEventListener('message', (event) => {
  if (event.data && event.data.type === 'SKIP_WAITING') {
    self.skipWaiting();
  }
});

// Handle offline fallback for navigation only
self.addEventListener('fetch', (event) => {
  // Don't interfere with stream or API requests
  if (event.request.url.includes('/mjpeg') || 
      event.request.url.includes('/stream') ||
      event.request.url.includes('/api') ||
      event.request.url.includes('mjpeg')) {
    return; // Let the request pass through normally
  }

  if (event.request.mode === 'navigate') {
    event.respondWith(
      fetch(event.request).catch(() => {
        return caches.match('/offline.html');
      })
    );
  }
});
